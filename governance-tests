diff --git a/contracts/DisputeManager.sol b/contracts/DisputeManager.sol
index 86c59eb..faab025 100644
--- a/contracts/DisputeManager.sol
+++ b/contracts/DisputeManager.sol
@@ -68,10 +68,7 @@ contract DisputeManager is Governed {
 
     /* Contract Constructor */
     /* @param _governor <address> - Address of the multisig contract as Governor of this contract */
-    constructor (address _governor) public Governed(_governor)
-    {
-        revert();
-    }
+    constructor (address _governor) public Governed(_governor) {}
 
     /* Graph Protocol Functions */
     /**
diff --git a/contracts/GNS.sol b/contracts/GNS.sol
index 9223a7a..1e8fcc3 100644
--- a/contracts/GNS.sol
+++ b/contracts/GNS.sol
@@ -56,10 +56,7 @@ contract GNS is Governed {
 
     /* Contract Constructor */
     /* @param _governor <address> - Address of the multisig contract as Governor of this contract */
-    constructor (address _governor) public Governed (_governor)
-    {
-        revert();
-    }
+    constructor (address _governor) public Governed (_governor) {}
 
     /* Graph Protocol Functions */
 
diff --git a/contracts/GraphToken.sol b/contracts/GraphToken.sol
index 7f78ea4..04a1396 100644
--- a/contracts/GraphToken.sol
+++ b/contracts/GraphToken.sol
@@ -35,6 +35,13 @@ contract GraphToken is
         _;
     }
     
+    /* Init Graph Token contract */
+    /* @param _governor <address> - Address of the multisig contract as Governor of this contract */
+    /* @param _initialSupply <uint256> - Initial supply of Graph Tokens */
+    constructor (address _governor, uint256 _initialSupply) public Governed (_governor) {}
+    
+    /* Graph Protocol Functions */
+
     /* 
      * @dev Init Graph Token contract
      * @param _governor <address> Address of the multisig contract as Governor of this contract
diff --git a/contracts/RewardsManager.sol b/contracts/RewardsManager.sol
index e59b3e5..3cf4c51 100644
--- a/contracts/RewardsManager.sol
+++ b/contracts/RewardsManager.sol
@@ -56,10 +56,7 @@ contract RewardsManager is Governed {
      * @dev Reward Manager Contract Constructor
      * @param _governor <address> - Address of the multisig contract as Governor of this contract
      */
-    constructor (address _governor) public Governed (_governor)
-    {
-        revert();
-    }
+    constructor (address _governor) public Governed (_governor) {}
 
     /* Graph Protocol Functions */
     /**
diff --git a/contracts/ServiceRegistry.sol b/contracts/ServiceRegistry.sol
index 482366f..f6e6cdd 100644
--- a/contracts/ServiceRegistry.sol
+++ b/contracts/ServiceRegistry.sol
@@ -25,10 +25,7 @@ contract ServiceRegistry is Governed {
 
     /* Contract Constructor */
     /* @param _governor <address> - Address of the multisig contract as Governor of this contract */
-    constructor (address _governor) public Governed (_governor)
-    {
-        revert();
-    }
+    constructor (address _governor) public Governed (_governor) {}
 
     /* Graph Protocol Functions */
 
diff --git a/contracts/Staking.sol b/contracts/Staking.sol
index b31317b..9e7434e 100644
--- a/contracts/Staking.sol
+++ b/contracts/Staking.sol
@@ -87,10 +87,7 @@ contract Staking is Governed {
      * @dev Staking Contract Constructor
      * @param _governor <address> - Address of the multisig contract as Governor of this contract
      */
-    constructor (address _governor) public Governed (_governor)
-    {
-        revert();
-    }
+    constructor (address _governor) public Governed (_governor) {}
 
     /**
      * @dev Set the Minimum Staking Amount for Market Curators
diff --git a/package.json b/package.json
new file mode 100644
index 0000000..358db36
--- /dev/null
+++ b/package.json
@@ -0,0 +1,8 @@
+{
+  "name": "graphtoken",
+  "version": "1.0.0",
+  "main": "truffle.js",
+  "dependencies": {
+    "openzeppelin-solidity": "2.1.1"
+  }
+}
diff --git a/test/governance.test.js b/test/governance.test.js
new file mode 100644
index 0000000..c005c16
--- /dev/null
+++ b/test/governance.test.js
@@ -0,0 +1,127 @@
+const MultiSigWallet = artifacts.require("./MultiSigWallet.sol")
+const UpgradableContract = artifacts.require("./GNS.sol")
+
+contract('UpgradableContract', accounts => {  
+
+  let multiSigInstances = new Array(2)
+  let governedInstances = new Array(5)
+
+  before(async () => {
+
+    // Deploy a first multisig contract to be used as `governor` when deploying the upgradable contracts
+    multiSigInstances[0] = await MultiSigWallet.new(
+      [accounts[0], accounts[1], accounts[2]], // owners
+      2 // required confirmations
+    )
+
+    // Deploy a second multisig contract to test transferring governance to a new governor
+    multiSigInstances[1] = await MultiSigWallet.new(
+      [accounts[3], accounts[4], accounts[5]], // owners
+      2 // required confirmations
+    )
+
+    // Init 5 Governed contracts
+    const governor1 = multiSigInstances[0].address
+    governedInstances[0] = await UpgradableContract.new(governor1)
+    governedInstances[1] = await UpgradableContract.new(governor1)
+    governedInstances[2] = await UpgradableContract.new(governor1)
+    governedInstances[3] = await UpgradableContract.new(governor1)
+    governedInstances[4] = await UpgradableContract.new(governor1)
+
+  })
+
+  it("...should be governed by MultiSigWallet #1", async () => {
+    const governor = await governedInstances[0].governor.call()
+    assert(
+      governor == multiSigInstances[0].address,
+      "MultiSigWallet1 is the governor."
+    )
+  })
+
+  it("...should be able to transfer governance of self to MultiSigWallet #2", async () => {
+    // Encode transaction data to be executed by the multisig upon confirmation
+    const txData = governedInstances[0].contract.methods.transferGovernance(
+      multiSigInstances[1].address
+    ).encodeABI()
+    assert(txData.length, "Transaction data is constructed.")
+
+    // Submit the transaction to the multisig for confirmation
+    const transaction = await multiSigInstances[0].submitTransaction(
+      governedInstances[0].address, // destination contract
+      0, // value
+      txData // transaction data
+    )
+    assert.isObject(transaction, "Transaction saved.")
+
+    // Get the `transactionId` from the logs
+    const transactionId = getParamFromTxEvent(
+      transaction,
+      'transactionId',
+      null,
+      'Submission'
+    )
+    assert(!isNaN(transactionId.toNumber()), "Transaction ID found.")
+
+    // The transaction should be pending with only 1 confirmation
+    let pendingTransactionCount = await multiSigInstances[0].getTransactionCount(
+      true, // include pending
+      false // include executed
+    )
+    assert(pendingTransactionCount.toNumber() === 1, "Transaction is pending.")
+
+    // Confirm transaction from a second multisig owner account
+    await multiSigInstances[0].contract.methods.confirmTransaction(
+      transactionId.toNumber()
+    ).send({from: accounts[1]})
+
+    // Check status is no longer `pending`
+    pendingTransactionCount = await multiSigInstances[0].getTransactionCount(
+      true, // include pending
+      false // include executed
+    )
+    assert(pendingTransactionCount.toNumber() === 0, "Transaction is not pending.")
+
+    // Check that we now have 2 confirmations
+    const confirmations = await multiSigInstances[0].getConfirmations(transactionId.toNumber())
+    assert(confirmations.length === 2, "Transaction has 2 confirmations.")
+
+    // Check that transaction status is `confirmed`
+    const isConfirmed = await multiSigInstances[0].isConfirmed(transactionId.toNumber())
+    assert(isConfirmed, "Transaction is confirmed.")
+
+    // Check that 1 transaction has been `executed` 
+    const executedTransactionCount = await multiSigInstances[0].getTransactionCount(
+      false, // include pending
+      true // include executed
+    )
+    assert(executedTransactionCount.toNumber() === 1, "Transaction has been executed.")
+
+    // Governor of the upgradable contract should now be the second multisig contract
+    assert.equal(
+      await governedInstances[0].governor.call(), // contract's new governor
+      multiSigInstances[1].address, // second multisig instance
+      'Upgradable contract has new governor.'
+    )
+
+  })
+  
+})
+
+// @todo Use a better method to parse event logs. This is limited
+// @dev See possible replacment: https://github.com/rkalis/truffle-assertions
+function getParamFromTxEvent(transaction, paramName, contractFactory, eventName) {
+  assert.isObject(transaction)
+  let logs = transaction.logs || transaction.events || []
+  if(eventName != null) {
+      logs = logs.filter((l) => l.event === eventName)
+  }
+  assert.equal(logs.length, 1, 'too many logs found!')
+  let param = logs[0].args[paramName]
+  if(contractFactory != null) {
+      let contract = contractFactory.at(param)
+      assert.isObject(contract, `getting ${paramName} failed for ${param}`)
+      return contract
+  } else {
+      return param
+  }
+}
\ No newline at end of file
