#!/usr/bin/env node

/**
 * Generate interface ID constants by deploying and calling InterfaceIdExtractor contract
 */

// This script is designed to be run via `npx hardhat run` which handles the module loading
const hre = require('hardhat')
const fs = require('fs')
const path = require('path')

async function main() {
  const outputFile = path.join(__dirname, '..', 'src', 'interfaceIds.ts')
  const extractorPath = path.join(__dirname, '..', 'contracts', 'utils', 'InterfaceIdExtractor.sol')

  // Check if regeneration is needed
  if (fs.existsSync(outputFile) && fs.existsSync(extractorPath)) {
    const outputStat = fs.statSync(outputFile)
    const extractorStat = fs.statSync(extractorPath)

    if (outputStat.mtime > extractorStat.mtime) {
      // Output is newer than source, no need to regenerate
      return
    }
  }

  // Deploy the InterfaceIdExtractor contract
  const InterfaceIdExtractor = await hre.ethers.getContractFactory('InterfaceIdExtractor')
  const extractor = await InterfaceIdExtractor.deploy()
  await extractor.waitForDeployment()

  // Automatically discover all getter methods that return interface IDs
  const results = {}
  const contractInterface = extractor.interface

  // Find all functions that start with 'get' and end with 'Id' and are view/pure functions
  for (const fragment of contractInterface.fragments) {
    if (
      fragment.type === 'function' &&
      fragment.name.startsWith('get') &&
      fragment.name.endsWith('Id') &&
      (fragment.stateMutability === 'view' || fragment.stateMutability === 'pure') &&
      fragment.inputs.length === 0 && // No parameters
      fragment.outputs.length === 1 && // Single return value
      fragment.outputs[0].type === 'bytes4'
    ) {
      // Returns bytes4

      // Extract interface name from method name: getIRewardsManagerId -> IRewardsManager
      const interfaceName = fragment.name.replace(/^get/, '').replace(/Id$/, '')

      try {
        const interfaceId = await extractor[fragment.name]()
        results[interfaceName] = interfaceId
      } catch (error) {
        console.warn(`⚠️  Failed to call ${fragment.name}: ${error.message}`)
      }
    }
  }

  // Convert to hex strings
  const processed = {}
  for (const [name, value] of Object.entries(results)) {
    processed[name] = typeof value === 'string' ? value : `0x${BigInt(value).toString(16).padStart(8, '0')}`
  }

  // Generate TypeScript content
  const content = `/**
 * Auto-generated interface IDs from Solidity compilation
 *
 * DO NOT EDIT THIS FILE MANUALLY!
 *
 * This file is automatically generated by running:
 * pnpm hardhat run scripts/generateInterfaceIds.js --network hardhat
 *
 * To add a new interface ID:
 * 1. Add the interface import and getter method to contracts/utils/InterfaceIdExtractor.sol
 * 2. Run the generation script above
 */

export const INTERFACE_IDS = {
${Object.entries(processed)
  .map(([name, id]) => `  ${name}: '${id}',`)
  .join('\n')}
} as const

// Individual exports for convenience
${Object.entries(processed)
  .map(([name]) => `export const ${name} = INTERFACE_IDS.${name}`)
  .join('\n')}
`

  // Write to output file
  fs.mkdirSync(path.dirname(outputFile), { recursive: true })
  fs.writeFileSync(outputFile, content)

  console.log(`Generated interface IDs: ${Object.keys(processed).join(', ')}`)
}

main().catch((error) => {
  console.error(error)
  process.exit(1)
})
